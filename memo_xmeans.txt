x-meansをGPU(ComputeShader)で回す

各画素は None, positive, negative のラベルを持つ
  positiveのみのバッファ、negativeのみのバッファに分けてx-meansへ

トラッカーでのx-means実装
欲しいのは各クラスタの重心
  汎用性のために各データ点の配属クラスタも出したい
クラスタIDの割り当て
  分割深度=ビット として割り当て
  最大分割回数 = IDのビット数
各データ点に属するデータ
  座標
  割り当てクラスタ
各クラスタに属するデータ
  データ点数
  重心
  分散
  BIC
各データ点のクラスタ分割計算用バッファ
各クラスタの計算用バッファ

x-means on GPU
  並列計算
    クラスタ割り当て: 完全に並列
    クラスタ移動の検知: 2クラスタの総和
    データ点数: クラスタ内の総和
    重心: クラスタ内の総和
    分散: クラスタ内の総和
    BIC: クラスタ内の総和, 積
  総和を求める
    クラスタはメモリが連続であってほしい
      k=2程度であれば混ざっていても大丈夫
      k2-means実行後にソートする
    クラスタのサイズによっては複数workgroupにまたがる
      workgroup内計算結果を合算する必要がある
      今回は実装しない(単一workgroupに全部乗ると仮定)

x-means on GPU
  それぞれ別の呼び出しで実行
    k2-means
    ソート: クラスタ数/2の並列
      クイックソートの分割と同様






x-means
  クラスタをさらにk-means(k=2)で分割した方がよいかを判定する
    BICが小さくなるなら分割
  k-means(k=2)を内部で使う

k-means++
  k-meansの初期化方法の改良
  クラスタ中心どうしの距離が大きくなるよう確率的に初期化
  k=2なら要らんか
アルゴリズム
  ランダムなデータ点ひとつをクラスタ重心とする
  クラスタ重心の数がkになるまで繰り返す
    各データ点について、既存クラスタ中心との距離のうち最小のものを重みとする
    重みに従ってデータ点をランダムピックしてクラスタ重心とする

k-means
アルゴリズム
  クラスタ重心を初期化する
  収束するまで繰り返す
    データ点を最近傍の重心を持つクラスタに再割り当て
    変更フラグを立てる
    クラスタ重心の計算

x-meansの評価部分(Maximaで確認するのがいいか)
  BIC(Bayesian Information Criterion)
    BIC = -2 * log(L) + q * log(num_data)
    L : 尤度関数
    q : 母数あるいは独立変数の数
    //共分散を無視するとき q = 2*p
    //データがn次元のとき p = n
  尤度関数
    L = f(data[0]) * ... * f(data[num_data - 1])
  クラスタが従うと仮定する多変量正規分布
    f(x) = (2*PI)^(-p/2) * det(V)^(-1/2) * exp(-1/2 * (x-mean)T . inv(V) . (x-mean) )
    V ... 分散共分散行列  ///ただし共分散=0
  計算
    式を整理して xmeans_maxima.BIC_simp
x-meansの2分割評価
  BIC_div
    BIC_div = -2 * log(L_div) + q_div * log(num_data)
    q_div = 2*q
  クラスタC1+C2が従うと仮定する多変量正規分布
    f_div(x) ~= 0.5 / K(a) * ((C1 include x) ? f1(x) : f2(x))
    K : 標準正規分布の下側確率(累積分布関数)
      解析的に解けないので近似関数を使う
      K(x) = 1 / (1 + exp(-PI*x/1.7) )
    a = len(mean1 - mean2) * (det(V1) + det(V2))^(-1/2)
  尤度関数
    L_div = 0.5 / K(a) * L1 * L2
    logL1 = -(BIC1 - q*log(num_data1)) / 2
  計算
    式を整理して xmeans_maxima.BIC_div_simp
