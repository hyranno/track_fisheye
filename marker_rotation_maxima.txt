/* batch(filepath); */

kill(all)$

load(vect)$
load(grobner)$
solveradcan : true$
solveexplicit : false$

flatten_mat(m) := flatten(args(m))$
cros(u,v) := block(
  [uf, vf],
  uf : flatten_mat(u),
  vf : flatten_mat(v),
  [uf[2]*vf[3]-uf[3]*vf[2], uf[3]*vf[1]-uf[1]*vf[3], uf[1]*vf[2]-uf[2]*vf[1]]
)$
norm(v) := sqrt(v.v)$


p0 : [0,0,0]$
p1 : [c,0,0]$
p2 : [0,c,0]$
src1 : [x1, y1, sqrt(c^2-(x1^2+y1^2))]$
src2 : [x2, y2, sqrt(c^2-(x2^2+y2^2))]$
/*
src1 = rotate(p1)$
src2 = rotate(p2)$
*/

declare(c, real)$
declare(x1, real, y1, real, z1, real)$
declare(x2, real, y2, real, z2, real)$
assume(c > 0)$
assume(c^2 >= x1^2 + y1^2)$
assume(c^2 >= x2^2 + y2^2)$
/*
src1.src2 = 0
x1*x2 + y1*y2 +sqrt(c^2-(x1^2+y1^2))*sqrt(c^2-(x2^2+y2^2)) = 0
 */

ans : solve((x1*x2 + y1*y2)^2 = (c^2-(x1^2+y1^2))*(c^2-(x2^2+y2^2)), c)$
rootscontract(ans)[2];
/*
ev(rootscontract(expand(rootscontract( (x1*x2 + y1*y2)^2 = (c^2-(x1^2+y1^2))*(c^2-(x2^2+y2^2)) ))), ans[2])$
*/

/*
rx : [x1/c, y1/c, sqrt(1-(x1/c)^2-(y1/c)^2)]
ry : [x2/c, y2/c, sqrt(1-(x2/c)^2-(y2/c)^2)]
rz : cros(src1/c, src2/c)
dcm : matrix(
  [rx[1], ry[1], rz[1]],
  [rx[2], ry[2], rz[2]],
  [rx[3], ry[3], rz[3]],
);
DCM to quaternion
 */
