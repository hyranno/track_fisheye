
kill(all)$

load(vect)$
load(grobner)$
solveradcan : true$
solveexplicit : false$

flatten_mat(m) := flatten(args(m))$
colvec(l) := transpose(matrix(l))$
mat(l) := apply('matrix,l)$
cros(u,v) := block(
  [uf, vf],
  uf : flatten_mat(u),
  vf : flatten_mat(v),
  [uf[2]*vf[3]-uf[3]*vf[2], uf[3]*vf[1]-uf[1]*vf[3], uf[1]*vf[2]-uf[2]*vf[1]]
)$

perspective(f,p) := block(
  [pf,X,Y,s],
  pf : flatten_mat(p),
  s : f / pf[3],
  X : pf[1] * s,
  Y : pf[2] * s,
  [X,Y]
)$
calc_dcm(ax1, ax2) := block( /* ax1, ax2 should be normalized */
  [af1, af2],
  af1 : flatten_mat(ax1),
  af2 : flatten_mat(ax2),
  mat([
    [af1[1], af2[1], cros(af1,af2)[1]],
    [af1[1], af2[1], cros(af1,af2)[1]],
    [af1[1], af2[1], cros(af1,af2)[1]]
  ])
)$
mul_quaternion(q1, q2) := block( /* q1, q2 should be normalized column vector */
  [qf,m],
  qf : flatten_mat(q1),
  m : mat([
    [+qf[4], -qf[3], +qf[2], +qf[1]],
    [+qf[3], +qf[4], -qf[1], +qf[2]],
    [-qf[2], +qf[1], +qf[4], +qf[3]],
    [-qf[1], -qf[2], -qf[3], +qf[4]]
  ]),
  m.q2
)$
inv_quaternion(q) := block(
  [qf],
  qf : flatten_mat(q),
  colvec([qf[1], qf[2], qf[3], -qf[4]])
)$
rot_quaternion(q, v) := block(
  [vf, qv, rv],
  vf : flatten_mat(v),
  qv : colvec([vf[1], vf[2], vf[3], 0]),
  rv : flatten_mat( mul_quaternion( mul_quaternion(q, qv), inv_quaternion(q)) ),
  colvec([rv[1], rv[2], rv[3]])
)$


p0 : colvec([0,0,0])$
p1 : colvec([c,0,0])$
p2 : colvec([0,c,0])$
declare(c, real)$
assume(c > 0)$

Tr : colvec([Tr[1], Tr[2], Tr[3]])$
rotq : colvec([qx, qy, qz, qw])$
declare(Tr, real)$
declare(qx, real, qy, real, qz, real, qw, real)$
assume(1 >= (qx^2 + qy^2 + qz^2 + qw^2))$ /* equal */
/*
rotq : colvec([
  sqrt(1-qw^2)*qx,
  sqrt(1-qw^2)*qy,
  sqrt(1-qw^2)*sqrt(1-(qx^2+qy^2)),
  qw
])$
*/

P_pos : perspective(f, Tr);
P_rot1 : perspective(f, rot_quaternion(rotq, p1) + Tr);
P_rot2 : perspective(f, rot_quaternion(rotq, p2) + Tr);
declare(f, real)$

Pp : [Pp[0], Pp[1], Pp[2]]$
Pa : [Pa[0], Pa[1], Pa[2]]$
Pb : [Pb[0], Pb[1], Pb[2]]$
declare(Pp, real, Pa, real, Pb, real)$


vars : [Tr[1],Tr[2],Tr[3], qx,qy,qz,qw]$
eqns : [
  1 = qx^2 + qy^2 + qz^2 + qw^2,
  Pp[1] = P_pos[1],
  Pp[2] = P_pos[2],
  Pa[1] = P_rot1[1],
  Pa[2] = P_rot1[2],
  Pb[1] = P_rot2[1],
  Pb[2] = P_rot2[2]
];
polys : [
  1 - (qx^2 + qy^2 + qz^2 + qw^2),
  Pp[1] - P_pos[1],
  Pp[2] - P_pos[2],
  Pa[1] - P_rot1[1],
  Pa[2] - P_rot1[2],
  Pb[1] - P_rot2[1],
  Pb[2] - P_rot2[2]
]$


gb : poly_grobner(polys, vars);
gbr : poly_reduced_grobner(polys, vars);

/* ans : solve(eqns, vars); */

/*
*/
